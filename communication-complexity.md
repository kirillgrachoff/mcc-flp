# Коммуникационная сложность с использованием асинхронного канала, FLP невозможность, не принадлежность задачи консенсуса ни одному из классов коммуникационной сложности

Понятие `Communication Complexity` (`CC`) было введено в 1979 Эндрю Яо.

## Определение (`Communication Complexity`, `CC`)
- Пусть дана функция $f(x_1, x_2) : \{0, 1\}^n \rightarrow \{0, 1\}$.
- Пусть учасвтуют *узлы* $P_1, P_2$, где *узел* $P_i$ знает $x_i$.
- Пусть они умеют обмениваться сообщениями по какому-то *каналу связи* используя какой-то заранее известный *протокол вычисления функции*.
- Требуется вычислить значение функции хотя бы на одном узле.

Коммуникационной сложности функции $f$ - ($D(f)$) называется минимальное количество бит коммуникации, которого достаточно для решения поставленной задачи в худшем случае (то есть этого количества битов должно быть достаточно для любой пары $x,y$).

## Определение (`Multi-Communication Complexity`, `MCC`)
Это "generalized communication complexity".
Отличиями является то, что
- $n \ge 3$.
- функцию должны вычислить все узлы.

## Определение (`Channel`)
- Сообщение ($m$) доставляется от отправителя получателю.
- Сообщение $m$ может дойти только полностью и не изменённым.

## Определение (`Asynchronous channel`)
Это канал передачи сообщений со следующими условиями:
- Время доставки сообщения может быть сколь угодно большим.

## Определение (`Faulty process`)
Это процесс ($P_i$), подверженный следующим ошибкам:
- Полный отказ (прекращение получения и отправки сообщений)
- Временно недоступен (временный отказ канала связи; сообщения не доставляются (или теряются) и не отправляются)

# Задача консенсуса
В распределённых системах часто возникает задача консенсуса - выбора одного из значений, предложенных участниками алгоритма, причём таким образом, чтобы каждый участник алгоритма знал результат. Более просто: Каждый участник алгоритма $P_i$ знает значение $x_i$. Нужно всем выбрать один $k$ и $x_k$ на всех.

## Определение (`Consensus`)
Это функция $f : (x_1, \dots x_n) \rightarrow X, x_i \in X$, обладающая следующими свойствами:
- Safety: $f (x_1, \dots x_n) \in \{ x_1, \dots x_n \}$

# Смысл
В данном документе я покажу, что задача консенсуса не может быть решена за конечное время (конечное к-во сообщений), а поэтому не лежит ни в одном классе коммуникационной сложности `MCC`.

# FLP невозможность
Не существует алгоритма консенсуса, обладающего следующими свойствами:
- $n \ge 3$
- Алгоритм завершается за конечное время
- Алгоритм завершается при $\ge 1$ отказе
- Канал связи асинхронный
- Алгоритм детерминирован (действия узлов зависят только от сообщений, которые они получают, и их порядка)

## Определения для доказательства
- Процесс: детерменированный автомат с операциями:
  - `recv(): msg` - ожидание и принятие сообщения
  - `send(msg)` - отослать сообщение
  - `decide(value)` - "выбрать" значение `value`; может быть вызван лишь один раз
- Конфигурация: состояние всех процессов и сообщения в пути
- Шаг: доставка какого-то сообщения и последующее изменение внутреннего состояние адресата
- Исполнение: последовательность шагов из какой-то начальной конфигурации
- Отказавший процесс: процесс, делающий конечное количество шагов автомата
- Валентность состояния $w$.
  - $i$-валентность: все исполнения из $w$ влекут выбор $i$
  - бивалентность: не $i$-валентность

## Доказательство
Предположим противное. Пусть такой алгоритм существует.

### Лемма 1
Существует начальная бивалентная конфигурация.

От противного: рассмотрим начальные значения для каждого процесса: $(0, 0, \dots 0), (1, 0, \dots 0), \dots (1, 1, \dots 1)$. Т.к. они все одновалентные, существуют $0$ и $1$-валентные соседние начальные ситуации $k - 1$-ая и $k$-ая. Рассмотрим их. Пусть в начале каждого исполнения отказывает узел $k$. Тогда алгоритм завершится с одним состоянием т.к. алгоритм детерменирован, а значения на не отказавших узлах одинаковые. Но валентности начальных конфигураций разные, а значит и результаты будут разные (противоречие)

### Лемма 2
Из бивалентной конфигурации существует переход в бивалентную

От противного: пусть это не так. Т.е. после какой-то бивалентной конфигурации $G$ все шаги ведут лишь в одновалентные.
Тогда есть следующее:
- $m$ - шаг доставки (какого-то) сообщения $M$ (какому-то) процессу $P$ (существует т.к. иначе в конфигурации решение не принято, алгоритм детерменированный, но ничего не происходит)
- $C$ - множество конфигураций, достижимое из $G$ без использования $m$ (по предположению содержит одновалентные)
- $D := m(C)$ - множество конфигураций, где $m$ - последнее обработанное событие.

Замечание: сейчас и далее события не будут перекрываться. Т.е. все события происходят друг за другом.

Докажем, что в $D$ есть бивалентная конфигурация.

#### Лемма 2.1
$\forall i \exists$ $i$-валентная конфигурация в $D$

Если $G$ бивалентна, то $\forall i$ из неё можно дойти до $i$-валентной конфигурации $E_i$. (по определению) Есть несколько случаев:
1. $E_i \in D \Rightarrow$ лемма доказана
2. Ребро $e$ применялось для достижения $E_i$ из $G$. Найдём $F_i$ - конфигурацию, получившуюся сразу после применения $e$. $F_i \in D$. Т.к. в $D$ нет бивалентных конфигураций (предположение леммы 2), $F_i$ - $i$-валентная, что и было нужно $\Rightarrow$ лемма доказана.
3. $E_i \in C \Rightarrow e(E_i) \in D$ и у $e(E_i)$ такая же валентность, как и у $e(E_i) \Rightarrow$ лемма доказана.

#### Лемма 2.2
Существуют соседние разновалентные конфигурации.
Т.е. $C_0, C_1 \in C$ т.ч. $\exists e' : C_1 = e'(C_0)$ и $D_0 = e(C_0)$ и $D_1 = e(C_1)$ и $D_0, D_1 \in D$ разновалентные.

Т.к. в $D$ существует 1- и 0-валентная конфигурация, причём в $D$ нет бивалентных, существуют 1- и 0-валентные конфигурации, полученные из каких-то элементов $C$ с пом. $e$. Т.к. из любой конфигурации из $C$ есть переход $e$ в $D$, можно найти такие $C_1$ и $C_0$, которые будут соседними, иначе для любого пути $v$ из $G$ валентность $e(v_i)$ будет совпадать с валентностью $e(G)$, что противоречит лемме 2.1.

#### Лемма 2.3
Теперь есть $C_0, C_1 \in C$ т.ч.
- $C_1 = e'(C_0)$
- $e(C_0) = D_0$ - 0-валентная (б.о.о.)
- $e(C_1) = D_1$ - 1-валентная

Рассмотрим $e'(D_0)$. Докажем, что оно не может не совпадать с $D_1$.

Если $e$ и $e'$ - события разных процессов, то их порядок обработки не важен т.к. алгоритм детерменированный, транспорт асинхронный и процессы изолированы друг от друга.

Имеем: $e(D_0) = D_1$, $D_0$ - 0-валентная, а $D_1$ - 1-валентная. Противоречие с предположением леммы 2.

Если $e$ и $e'$ - события одного процесса $p$, то рассмотрим путь $\xi$ от $C_0$ до $A$, где процесс $p$ отказал во время конфигурации $C_0$. Т.е. $\xi(C_0) = A$, причём $\xi$ не содержит $e, e'$. Тогда $A$ - либо 0-валентная, либо 1-валентная.
Теперь можно сказать, что процесс $p$ не отказал, а просто долго получал сообщения. Т.к. $\xi$ не зависит от $p$, то $\xi(e(C_0)) = e(\xi(C_0)) = E_0 = \xi(D_0)$ - конфигурация, достижимая из 0-валентной $\Rightarrow$ 0-валентная.
С другой стороны, можно рассмотреть $E_1 = e(e'(\xi(C_0))) = \xi(e(e'(C_0))) = \xi(e(C_1)) = \xi(D_1)$ - 1-валентная конфигурация.

В итоге, из $A$ достижимы 1-валентная и 0-валентная конфигурации, хотя $A$ - не бивалентная. Противоречие с предположением леммы 2.

Имеем:
- Существует начальная бивалентная конфигурация
- Можно перейти из бивалентной конфигурации в бивалентную с доставкой произвольного наперёд заданного сообщения $m$.

Следовательно, алгоритма из условия теоремы, не существует т.к. возможно построить исполнение, где доставляются все сообщения и каждая конфигурация бивалентна (а значит, значение не будет выбрано)

# Итог

Проблема консенсуса не лежит ни в одном классе `MCC`.


# Литература
- https://cseweb.ucsd.edu/classes/wi19/cse291-b/5-multiparty.pdf
- https://arxiv.org/pdf/1904.09563.pdf
- https://logic.pdmi.ras.ru/~smal/files/smal-isaac18-talk.pdf
- https://ru.wikipedia.org/wiki/Коммуникационная_сложность
- https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf
