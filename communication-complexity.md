# Коммуникационная сложность с использованием асинхронного канала, FLP невозможность, не принадлежность задачи консенсуса ни одному из классов сложности

Понятие `Communication Complexity` (`CC`) было введено в 1979 Эндрю Яо.

## Определение (`Communication Complexity`, `CC`)
- Пусть дана функция $f(x_1, x_2) : \{0, 1\}^n \rightarrow \{0, 1\}$.
- Пусть учасвтуют *узлы* $P_1, P_2$, где *узел* $P_i$ знает $x_i$.
- Пусть они умеют обмениваться сообщениями по какому-то *каналу связи* используя какой-то заранее известный *протокол вычисления функции*.
- Требуется вычислить значение функции хотя бы на одном узле.

Коммуникационной сложности функции $f$ - ($D(f)$) называется минимальное количество бит коммуникации, которого достаточно для решения поставленной задачи в худшем случае (то есть этого количества битов должно быть достаточно для любой пары $x,y$).

## Определение (`Multi-Communication Complexity`, `MCC`)
Это "generalized communication complexity".
Отличиями является то, что
- $n \ge 3$.
- функцию должны вычислить все узлы.

## Определение (`Channel`)
- Сообщение ($m$) доставляется от отправителя получателю.
- Сообщение $m$ может дойти только полностью и не изменённым.

## Определение (`Asynchronous channel`)
Это канал передачи сообщений со следующими условиями:
- Время доставки сообщения может быть сколь угодно большим.

## Определение (`Faulty process`)
Это процесс ($P_i$), подверженный следующим ошибкам:
- Полный отказ (прекращение получения и отправки сообщений)
- Временно недоступен (временный отказ канала связи; сообщения не доставляются (или теряются) и не отправляются)

# Задача консенсуса
В распределённых системах часто возникает задача консенсуса - выбора одного из значений, предложенных участниками алгоритма, причём таким образом, чтобы каждый участник алгоритма знал результат. Более просто: Каждый участник алгоритма $P_i$ знает значение $x_i$. Нужно всем выбрать один $k$ и $x_k$ на всех.

## Определение (`Consensus`)
Это функция $f : (x_1, \dots x_n) \rightarrow X, x_i \in X$, обладающая следующими свойствами:
- Safety: $f (x_1, \dots x_n) \in \{ x_1, \dots x_n \}$

# Смысл
В данном документе я покажу, что задача консенсуса не может быть решена за конечное время (конечное к-во сообщений), а поэтому не лежит ни в одном классе коммуникационной сложности `MCC`.

# FLP невозможность
Не существует алгоритма консенсуса, обладающего следующими свойствами:
- $n \ge 3$
- Алгоритм завершается за конечное время
- Алгоритм завершается при $\ge 1$ отказе
- Канал связи асинхронный
- Алгоритм детерминирован (действия узлов зависят только от сообщений, которые они получают, и их порядка)

## Определения для доказательства
- Процесс: детерменированный автомат с операциями:
  - `recv(): msg` - ожидание и принятие сообщения
  - `send(msg)` - отослать сообщение
  - `decide(value)` - "выбрать" значение `value`; может быть вызван лишь один раз
- Конфигурация: состояние всех процессов и сообщения в пути
- Шаг: доставка какого-то сообщения и последующее изменение внутреннего состояние адресата
- Исполнение: последовательность шагов из какой-то начальной конфигурации
- Отказавший процесс: процесс, делающий конечное количество шагов автомата
- Валентность состояния $w$.
  - $i$-валентность: все исполнения из $w$ влекут выбор $i$
  - бивалентность: не $i$-валентность

## Доказательство
Предположим противное. Пусть такой алгоритм существует.

### Лемма 1
Существует начальная бивалентная конфигурация.

От противного: рассмотрим начальные значения для каждого процесса: $(0, 0, \dots 0), (1, 0, \dots 0), \dots (1, 1, \dots 1)$. Т.к. они все одновалентные, существуют $0$ и $1$-валентные соседние начальные ситуации $k - 1$-ая и $k$-ая. Рассмотрим их. Пусть в начале каждого исполнения отказывает узел $k$. Тогда алгоритм завершится с одним состоянием т.к. алгоритм детерменирован, а значения на не отказавших узлах одинаковые. Но валентности начальных конфигураций разные, а значит и результаты будут разные (противоречие)

### Лемма 2
Из бивалентной конфигурации существует переход в бивалентную

От противного: пусть это не так. Т.е. после какой-то бивалентной конфигурации $G$ все шаги ведут лишь в одновалентные.
Тогда есть следующее:
- $m$ - шаг доставки (какого-то) сообщения $M$ (какому-то) процессу $P$ (существует т.к. иначе в конфигурации решение не принято, алгоритм детерменированный, но ничего не происходит)
- $C$ - множество конфигураций, достижимое из $G$ без использования $m$ (по предположению содержит одновалентные)
- $D := m(C)$ - множество конфигураций, где $m$ - последнее обработанное событие.

Замечание: сейчас и далее события не будут перекрываться. Т.е. все события происходят друг за другом.

Докажем, что в $D$ есть бивалентная конфигурация.

#### Лемма 2.1
$\forall i \exist$ $i$-валентная конфигурация в $D$

Если $G$ бивалентна, то $\forall i$ из неё можно дойти до $i$-валентной конфигурации $E_i$. (по определению) Есть несколько случаев:
1. $E_i \in D \Rightarrow$ лемма доказана
2. Ребро $e$ применялось для достижения $E_i$ из $G$. Найдём $F_i$ - конфигурацию, получившуюся сразу после применения $e$. $F_i \in D$. Т.к. в $D$ нет бивалентных конфигураций (предположение леммы 2), $F_i$ - $i$-валентная, что и было нужно $\Rightarrow$ лемма доказана.
3. $E_i \in C \Rightarrow e(E_i) \in D$ и у $e(E_i)$ такая же валентность, как и у $e(E_i) \Rightarrow$ лемма доказана.

# Литература
- https://cseweb.ucsd.edu/classes/wi19/cse291-b/5-multiparty.pdf
- https://arxiv.org/pdf/1904.09563.pdf
- https://logic.pdmi.ras.ru/~smal/files/smal-isaac18-talk.pdf
- https://ru.wikipedia.org/wiki/Коммуникационная_сложность